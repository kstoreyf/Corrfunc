
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Corrfunc.utils &#8212; Corrfunc v0.0.4</title>
    <link rel="stylesheet" href="../../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    <link rel="shortcut icon" href="../../_static/corrfunc-logo-no-text.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">Corrfunc v0.0.4</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../Corrfunc.html" accesskey="U">Corrfunc</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Corrfunc.utils</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for Corrfunc.utils</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">A set of utility routines</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="p">(</span><span class="n">absolute_import</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span><span class="p">,</span>
                        <span class="n">unicode_literals</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">os.path</span> <span class="kn">import</span> <span class="n">exists</span> <span class="k">as</span> <span class="n">file_exists</span>
<span class="kn">import</span> <span class="nn">wurlitzer</span>
<span class="kn">from</span> <span class="nn">contextlib</span> <span class="kn">import</span> <span class="n">contextmanager</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;convert_3d_counts_to_cf&#39;</span><span class="p">,</span> <span class="s1">&#39;convert_rp_pi_counts_to_wp&#39;</span><span class="p">,</span>
           <span class="s1">&#39;translate_isa_string_to_enum&#39;</span><span class="p">,</span> <span class="s1">&#39;return_file_with_rbins&#39;</span><span class="p">,</span>
           <span class="s1">&#39;fix_ra_dec&#39;</span><span class="p">,</span> <span class="s1">&#39;fix_cz&#39;</span><span class="p">,</span> <span class="s1">&#39;compute_nbins&#39;</span><span class="p">,</span> <span class="s1">&#39;gridlink_sphere&#39;</span><span class="p">,</span> 
           <span class="s1">&#39;compute_amps&#39;</span><span class="p">,</span> <span class="s1">&#39;evaluate_xi&#39;</span><span class="p">,</span> <span class="s1">&#39;qq_analytic&#39;</span><span class="p">,</span> <span class="p">]</span>
<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
    <span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">__all__</span><span class="p">]</span>

<span class="k">try</span><span class="p">:</span>
    <span class="n">xrange</span>
<span class="k">except</span> <span class="ne">NameError</span><span class="p">:</span>
    <span class="n">xrange</span> <span class="o">=</span> <span class="nb">range</span>

<div class="viewcode-block" id="convert_3d_counts_to_cf"><a class="viewcode-back" href="../../api/Corrfunc.html#Corrfunc.utils.convert_3d_counts_to_cf">[docs]</a><span class="k">def</span> <span class="nf">convert_3d_counts_to_cf</span><span class="p">(</span><span class="n">ND1</span><span class="p">,</span> <span class="n">ND2</span><span class="p">,</span> <span class="n">NR1</span><span class="p">,</span> <span class="n">NR2</span><span class="p">,</span>
                            <span class="n">D1D2</span><span class="p">,</span> <span class="n">D1R2</span><span class="p">,</span> <span class="n">D2R1</span><span class="p">,</span> <span class="n">R1R2</span><span class="p">,</span>
                            <span class="n">estimator</span><span class="o">=</span><span class="s1">&#39;LS&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts raw pair counts to a correlation function.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    ND1 : integer</span>
<span class="sd">       Number of points in the first dataset</span>

<span class="sd">    ND2 : integer</span>
<span class="sd">        Number of points in the second dataset</span>

<span class="sd">    NR1 : integer</span>
<span class="sd">        Number of points in the randoms for first dataset</span>

<span class="sd">    NR2 : integer</span>
<span class="sd">        Number of points in the randoms for second dataset</span>

<span class="sd">    D1D2 : array-like, integer</span>
<span class="sd">        Pair-counts for the cross-correlation between D1 and D2</span>

<span class="sd">    D1R2 : array-like, integer</span>
<span class="sd">        Pair-counts for the cross-correlation between D1 and R2</span>

<span class="sd">    D2R1 : array-like, integer</span>
<span class="sd">        Pair-counts for the cross-correlation between D2 and R1</span>

<span class="sd">    R1R2 : array-like, integer</span>
<span class="sd">        Pair-counts for the cross-correlation between R1 and R2</span>

<span class="sd">    For all of these pair-counts arrays, the corresponding ``numpy``</span>
<span class="sd">    struct returned by the theory/mocks modules can also be passed</span>

<span class="sd">    estimator: string, default=&#39;LS&#39; (Landy-Szalay)</span>
<span class="sd">        The kind of estimator to use for computing the correlation</span>
<span class="sd">        function. Currently, only supports Landy-Szalay</span>

<span class="sd">    Returns</span>
<span class="sd">    ---------</span>

<span class="sd">    cf : A numpy array</span>
<span class="sd">        The correlation function, calculated using the chosen estimator,</span>
<span class="sd">        is returned. NAN is returned for the bins where the ``RR`` count</span>
<span class="sd">        is 0.</span>


<span class="sd">    Example</span>
<span class="sd">    --------</span>

<span class="sd">    &gt;&gt;&gt; from __future__ import print_function</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from Corrfunc.theory.DD import DD</span>
<span class="sd">    &gt;&gt;&gt; from Corrfunc.io import read_catalog</span>
<span class="sd">    &gt;&gt;&gt; from Corrfunc.utils import convert_3d_counts_to_cf</span>
<span class="sd">    &gt;&gt;&gt; X, Y, Z = read_catalog()</span>
<span class="sd">    &gt;&gt;&gt; N = len(X)</span>
<span class="sd">    &gt;&gt;&gt; boxsize = 420.0</span>
<span class="sd">    &gt;&gt;&gt; rand_N = 3*N</span>
<span class="sd">    &gt;&gt;&gt; seed = 42</span>
<span class="sd">    &gt;&gt;&gt; np.random.seed(seed)</span>
<span class="sd">    &gt;&gt;&gt; rand_X = np.random.uniform(0, boxsize, rand_N)</span>
<span class="sd">    &gt;&gt;&gt; rand_Y = np.random.uniform(0, boxsize, rand_N)</span>
<span class="sd">    &gt;&gt;&gt; rand_Z = np.random.uniform(0, boxsize, rand_N)</span>
<span class="sd">    &gt;&gt;&gt; nthreads = 2</span>
<span class="sd">    &gt;&gt;&gt; rmin = 0.1</span>
<span class="sd">    &gt;&gt;&gt; rmax = 15.0</span>
<span class="sd">    &gt;&gt;&gt; nbins = 10</span>
<span class="sd">    &gt;&gt;&gt; bins = np.linspace(rmin, rmax, nbins + 1)</span>
<span class="sd">    &gt;&gt;&gt; autocorr = 1</span>
<span class="sd">    &gt;&gt;&gt; DD_counts = DD(autocorr, nthreads, bins, X, Y, Z)</span>
<span class="sd">    &gt;&gt;&gt; autocorr = 0</span>
<span class="sd">    &gt;&gt;&gt; DR_counts = DD(autocorr, nthreads, bins,</span>
<span class="sd">    ...                X, Y, Z,</span>
<span class="sd">    ...                X2=rand_X, Y2=rand_Y, Z2=rand_Z)</span>
<span class="sd">    &gt;&gt;&gt; autocorr = 1</span>
<span class="sd">    &gt;&gt;&gt; RR_counts = DD(autocorr, nthreads, bins, rand_X, rand_Y, rand_Z)</span>
<span class="sd">    &gt;&gt;&gt; cf = convert_3d_counts_to_cf(N, N, rand_N, rand_N,</span>
<span class="sd">    ...                              DD_counts, DR_counts,</span>
<span class="sd">    ...                              DR_counts, RR_counts)</span>
<span class="sd">    &gt;&gt;&gt; for xi in cf: print(&quot;{0:10.6f}&quot;.format(xi))</span>
<span class="sd">    ...                    # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">    22.769019</span>
<span class="sd">     3.612709</span>
<span class="sd">     1.621372</span>
<span class="sd">     1.000969</span>
<span class="sd">     0.691646</span>
<span class="sd">     0.511819</span>
<span class="sd">     0.398872</span>
<span class="sd">     0.318815</span>
<span class="sd">     0.255643</span>
<span class="sd">     0.207759</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
    <span class="n">pair_counts</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">fields</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;D1D2&#39;</span><span class="p">,</span> <span class="s1">&#39;D1R2&#39;</span><span class="p">,</span> <span class="s1">&#39;D2R1&#39;</span><span class="p">,</span> <span class="s1">&#39;R1R2&#39;</span><span class="p">]</span>
    <span class="n">arrays</span> <span class="o">=</span> <span class="p">[</span><span class="n">D1D2</span><span class="p">,</span> <span class="n">D1R2</span><span class="p">,</span> <span class="n">D2R1</span><span class="p">,</span> <span class="n">R1R2</span><span class="p">]</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="n">array</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">fields</span><span class="p">,</span> <span class="n">arrays</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">npairs</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="s1">&#39;npairs&#39;</span><span class="p">]</span>
            <span class="n">pair_counts</span><span class="p">[</span><span class="n">field</span><span class="p">]</span> <span class="o">=</span> <span class="n">npairs</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="n">pair_counts</span><span class="p">[</span><span class="n">field</span><span class="p">]</span> <span class="o">=</span> <span class="n">array</span>

    <span class="n">nbins</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pair_counts</span><span class="p">[</span><span class="s1">&#39;D1D2&#39;</span><span class="p">])</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">nbins</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pair_counts</span><span class="p">[</span><span class="s1">&#39;D1R2&#39;</span><span class="p">]))</span> <span class="ow">or</span> \
       <span class="p">(</span><span class="n">nbins</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pair_counts</span><span class="p">[</span><span class="s1">&#39;D2R1&#39;</span><span class="p">]))</span> <span class="ow">or</span> \
       <span class="p">(</span><span class="n">nbins</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pair_counts</span><span class="p">[</span><span class="s1">&#39;R1R2&#39;</span><span class="p">])):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Pair counts must have the same number of elements (same bins)&#39;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="n">nonzero</span> <span class="o">=</span> <span class="n">pair_counts</span><span class="p">[</span><span class="s1">&#39;R1R2&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="s1">&#39;LS&#39;</span> <span class="ow">in</span> <span class="n">estimator</span> <span class="ow">or</span> <span class="s1">&#39;Landy&#39;</span> <span class="ow">in</span> <span class="n">estimator</span><span class="p">:</span>
        <span class="n">fN1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">(</span><span class="n">NR1</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">(</span><span class="n">ND1</span><span class="p">)</span>
        <span class="n">fN2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">(</span><span class="n">NR2</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">(</span><span class="n">ND2</span><span class="p">)</span>
        <span class="n">cf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nbins</span><span class="p">)</span>
        <span class="n">cf</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">cf</span><span class="p">[</span><span class="n">nonzero</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">fN1</span> <span class="o">*</span> <span class="n">fN2</span> <span class="o">*</span> <span class="n">pair_counts</span><span class="p">[</span><span class="s1">&#39;D1D2&#39;</span><span class="p">][</span><span class="n">nonzero</span><span class="p">]</span> <span class="o">-</span>
                       <span class="n">fN1</span> <span class="o">*</span> <span class="n">pair_counts</span><span class="p">[</span><span class="s1">&#39;D1R2&#39;</span><span class="p">][</span><span class="n">nonzero</span><span class="p">]</span> <span class="o">-</span>
                       <span class="n">fN2</span> <span class="o">*</span> <span class="n">pair_counts</span><span class="p">[</span><span class="s1">&#39;D2R1&#39;</span><span class="p">][</span><span class="n">nonzero</span><span class="p">]</span> <span class="o">+</span>
                       <span class="n">pair_counts</span><span class="p">[</span><span class="s1">&#39;R1R2&#39;</span><span class="p">][</span><span class="n">nonzero</span><span class="p">])</span> <span class="o">/</span> <span class="n">pair_counts</span><span class="p">[</span><span class="s1">&#39;R1R2&#39;</span><span class="p">][</span><span class="n">nonzero</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cf</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nbins</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Bug in code. Calculated correlation function does not &#39;</span>\
                  <span class="s1">&#39;have the same number of bins as input arrays. Input bins &#39;</span>\
                  <span class="s1">&#39;=</span><span class="si">{0}</span><span class="s1"> bins in (wrong) calculated correlation = </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                      <span class="n">nbins</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">cf</span><span class="p">))</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Only the Landy-Szalay estimator is supported. Pass estimator&quot;</span>\
              <span class="s2">&quot;=&#39;LS&#39;. (Got estimator = </span><span class="si">{0}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">estimator</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">cf</span></div>


<div class="viewcode-block" id="convert_rp_pi_counts_to_wp"><a class="viewcode-back" href="../../api/Corrfunc.html#Corrfunc.utils.convert_rp_pi_counts_to_wp">[docs]</a><span class="k">def</span> <span class="nf">convert_rp_pi_counts_to_wp</span><span class="p">(</span><span class="n">ND1</span><span class="p">,</span> <span class="n">ND2</span><span class="p">,</span> <span class="n">NR1</span><span class="p">,</span> <span class="n">NR2</span><span class="p">,</span>
                               <span class="n">D1D2</span><span class="p">,</span> <span class="n">D1R2</span><span class="p">,</span> <span class="n">D2R1</span><span class="p">,</span> <span class="n">R1R2</span><span class="p">,</span>
                               <span class="n">nrpbins</span><span class="p">,</span> <span class="n">pimax</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
                               <span class="n">estimator</span><span class="o">=</span><span class="s1">&#39;LS&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts raw pair counts to a correlation function.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    ND1 : integer</span>
<span class="sd">       Number of points in the first dataset</span>

<span class="sd">    ND2 : integer</span>
<span class="sd">        Number of points in the second dataset</span>

<span class="sd">    NR1 : integer</span>
<span class="sd">        Number of points in the randoms for first dataset</span>

<span class="sd">    NR2 : integer</span>
<span class="sd">        Number of points in the randoms for second dataset</span>

<span class="sd">    D1D2 : array-like, integer</span>
<span class="sd">        Pair-counts for the cross-correlation between D1 and D2</span>

<span class="sd">    D1R2 : array-like, integer</span>
<span class="sd">        Pair-counts for the cross-correlation between D1 and R2</span>

<span class="sd">    D2R1 : array-like, integer</span>
<span class="sd">        Pair-counts for the cross-correlation between D2 and R1</span>

<span class="sd">    R1R2 : array-like, integer</span>
<span class="sd">        Pair-counts for the cross-correlation between R1 and R2</span>

<span class="sd">    For all of these pair-counts arrays, the corresponding ``numpy``</span>
<span class="sd">    struct returned by the theory/mocks modules can also be passed</span>

<span class="sd">    nrpbins : integer</span>
<span class="sd">        Number of bins in ``rp``</span>

<span class="sd">    pimax : float</span>
<span class="sd">        Integration distance along the line of sight direction</span>

<span class="sd">    dpi : float, default=1.0 Mpc/h</span>
<span class="sd">        Binsize in the line of sight direction</span>

<span class="sd">    estimator: string, default=&#39;LS&#39; (Landy-Szalay)</span>
<span class="sd">        The kind of estimator to use for computing the correlation</span>
<span class="sd">        function. Currently, only supports Landy-Szalay</span>

<span class="sd">    Returns</span>
<span class="sd">    ---------</span>

<span class="sd">    wp : A numpy array</span>
<span class="sd">        The projected correlation function, calculated using the chosen</span>
<span class="sd">        estimator, is returned. If *any* of the ``pi`` bins (in an ``rp``</span>
<span class="sd">        bin) contains 0 for the ``RR`` counts, then ``NAN`` is returned</span>
<span class="sd">        for that ``rp`` bin.</span>

<span class="sd">    Example</span>
<span class="sd">    --------</span>

<span class="sd">    &gt;&gt;&gt; from __future__ import print_function</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from Corrfunc.theory.DDrppi import DDrppi</span>
<span class="sd">    &gt;&gt;&gt; from Corrfunc.io import read_catalog</span>
<span class="sd">    &gt;&gt;&gt; from Corrfunc.utils import convert_rp_pi_counts_to_wp</span>
<span class="sd">    &gt;&gt;&gt; X, Y, Z = read_catalog()</span>
<span class="sd">    &gt;&gt;&gt; N = len(X)</span>
<span class="sd">    &gt;&gt;&gt; boxsize = 420.0</span>
<span class="sd">    &gt;&gt;&gt; rand_N = 3*N</span>
<span class="sd">    &gt;&gt;&gt; seed = 42</span>
<span class="sd">    &gt;&gt;&gt; np.random.seed(seed)</span>
<span class="sd">    &gt;&gt;&gt; rand_X = np.random.uniform(0, boxsize, rand_N)</span>
<span class="sd">    &gt;&gt;&gt; rand_Y = np.random.uniform(0, boxsize, rand_N)</span>
<span class="sd">    &gt;&gt;&gt; rand_Z = np.random.uniform(0, boxsize, rand_N)</span>
<span class="sd">    &gt;&gt;&gt; nthreads = 4</span>
<span class="sd">    &gt;&gt;&gt; pimax = 40.0</span>
<span class="sd">    &gt;&gt;&gt; nrpbins = 20</span>
<span class="sd">    &gt;&gt;&gt; rpmin = 0.1</span>
<span class="sd">    &gt;&gt;&gt; rpmax = 10.0</span>
<span class="sd">    &gt;&gt;&gt; bins = np.linspace(rpmin, rpmax, nrpbins + 1)</span>
<span class="sd">    &gt;&gt;&gt; autocorr = 1</span>
<span class="sd">    &gt;&gt;&gt; DD_counts = DDrppi(autocorr, nthreads, pimax, bins,</span>
<span class="sd">    ...                    X, Y, Z)</span>
<span class="sd">    &gt;&gt;&gt; autocorr = 0</span>
<span class="sd">    &gt;&gt;&gt; DR_counts = DDrppi(autocorr, nthreads, pimax, bins,</span>
<span class="sd">    ...                    X, Y, Z,</span>
<span class="sd">    ...                    X2=rand_X, Y2=rand_Y, Z2=rand_Z)</span>
<span class="sd">    &gt;&gt;&gt; autocorr = 1</span>
<span class="sd">    &gt;&gt;&gt; RR_counts = DDrppi(autocorr, nthreads, pimax, bins,</span>
<span class="sd">    ...                    rand_X, rand_Y, rand_Z)</span>
<span class="sd">    &gt;&gt;&gt; wp = convert_rp_pi_counts_to_wp(N, N, rand_N, rand_N,</span>
<span class="sd">    ...                                 DD_counts, DR_counts,</span>
<span class="sd">    ...                                 DR_counts, RR_counts,</span>
<span class="sd">    ...                                 nrpbins, pimax)</span>
<span class="sd">    &gt;&gt;&gt; for w in wp: print(&quot;{0:10.6f}&quot;.format(w))</span>
<span class="sd">    ...                    # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">    187.592199</span>
<span class="sd">     83.059181</span>
<span class="sd">     53.200599</span>
<span class="sd">     40.389354</span>
<span class="sd">     33.356371</span>
<span class="sd">     29.045476</span>
<span class="sd">     26.088133</span>
<span class="sd">     23.628340</span>
<span class="sd">     21.703961</span>
<span class="sd">     20.153125</span>
<span class="sd">     18.724781</span>
<span class="sd">     17.433235</span>
<span class="sd">     16.287183</span>
<span class="sd">     15.443230</span>
<span class="sd">     14.436193</span>
<span class="sd">     13.592727</span>
<span class="sd">     12.921226</span>
<span class="sd">     12.330074</span>
<span class="sd">     11.696364</span>
<span class="sd">     11.208365</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
    <span class="k">if</span> <span class="n">dpi</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Binsize along the line of sight (dpi) = </span><span class="si">{0}</span><span class="s1">&#39;</span>\
              <span class="s1">&#39;must be positive&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dpi</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="n">xirppi</span> <span class="o">=</span> <span class="n">convert_3d_counts_to_cf</span><span class="p">(</span><span class="n">ND1</span><span class="p">,</span> <span class="n">ND2</span><span class="p">,</span> <span class="n">NR1</span><span class="p">,</span> <span class="n">NR2</span><span class="p">,</span>
                                     <span class="n">D1D2</span><span class="p">,</span> <span class="n">D1R2</span><span class="p">,</span> <span class="n">D2R1</span><span class="p">,</span> <span class="n">R1R2</span><span class="p">,</span>
                                     <span class="n">estimator</span><span class="o">=</span><span class="n">estimator</span><span class="p">)</span>
    <span class="n">wp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">nrpbins</span><span class="p">)</span>
    <span class="n">npibins</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">xirppi</span><span class="p">)</span> <span class="o">//</span> <span class="n">nrpbins</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">npibins</span> <span class="o">*</span> <span class="n">nrpbins</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">xirppi</span><span class="p">)):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Number of pi bins could not be calculated correctly.&#39;</span>\
              <span class="s1">&#39;Expected to find that the total number of bins = </span><span class="si">{0}</span><span class="s1"> &#39;</span>\
              <span class="s1">&#39;would be the product of the number of pi bins = </span><span class="si">{1}</span><span class="s1"> &#39;</span>\
              <span class="s1">&#39;and the number of rp bins = </span><span class="si">{2}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xirppi</span><span class="p">),</span>
                                                       <span class="n">npibins</span><span class="p">,</span>
                                                       <span class="n">nrpbins</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="c1"># Check that dpi/pimax/npibins are consistent</span>
    <span class="c1"># Preventing issue #96 (https://github.com/manodeep/Corrfunc/issues/96)</span>
    <span class="c1"># where npibins would be calculated incorrectly, and the summation would</span>
    <span class="c1"># be wrong.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dpi</span><span class="o">*</span><span class="n">npibins</span> <span class="o">!=</span> <span class="n">pimax</span><span class="p">):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Pimax = </span><span class="si">{0}</span><span class="s1"> should be equal to the product of &#39;</span>\
              <span class="s1">&#39;npibins = </span><span class="si">{1}</span><span class="s1"> and dpi = </span><span class="si">{2}</span><span class="s1">. Check your binning scheme.&#39;</span>\
              <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pimax</span><span class="p">,</span> <span class="n">npibins</span><span class="p">,</span> <span class="n">dpi</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nrpbins</span><span class="p">):</span>
        <span class="n">wp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">dpi</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">xirppi</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="n">npibins</span><span class="p">:(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">npibins</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">wp</span></div>


<div class="viewcode-block" id="return_file_with_rbins"><a class="viewcode-back" href="../../api/Corrfunc.html#Corrfunc.utils.return_file_with_rbins">[docs]</a><span class="k">def</span> <span class="nf">return_file_with_rbins</span><span class="p">(</span><span class="n">rbins</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Helper function to ensure that the ``binfile`` required by the Corrfunc</span>
<span class="sd">    extensions is a actually a string.</span>

<span class="sd">    Checks if the input is a string and file; return if True. If not, and</span>
<span class="sd">    the input is an array, then a temporary file is created and the contents</span>
<span class="sd">    of rbins is written out.</span>

<span class="sd">    Parameters</span>
<span class="sd">    -----------</span>
<span class="sd">    rbins: string or array-like</span>
<span class="sd">       Expected to be a string or an array containing the bins</span>

<span class="sd">    Returns</span>
<span class="sd">    ---------</span>
<span class="sd">    binfile: string, filename</span>
<span class="sd">       If the input ``rbins`` was a valid filename, then returns the same</span>
<span class="sd">       string. If ``rbins`` was an array, then this function creates a</span>
<span class="sd">       temporary file with the contents of the ``rbins`` arrays. This</span>
<span class="sd">       temporary filename is returned</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">is_string</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">delete_after_use</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rbins</span><span class="p">,</span> <span class="n">basestring</span><span class="p">):</span>
            <span class="n">is_string</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">except</span> <span class="ne">NameError</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rbins</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">is_string</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">if</span> <span class="n">is_string</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">file_exists</span><span class="p">(</span><span class="n">rbins</span><span class="p">):</span>
            <span class="n">delete_after_use</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">return</span> <span class="n">rbins</span><span class="p">,</span> <span class="n">delete_after_use</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Could not find file = `</span><span class="si">{0}</span><span class="s2">` containing the bins&quot;</span>\
                  <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rbins</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="c1"># For a valid bin specifier, there must be at least 1 bin.</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rbins</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">tempfile</span>
        <span class="n">rbins</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">rbins</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">NamedTemporaryFile</span><span class="p">(</span><span class="n">delete</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rbins</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{0}</span><span class="s2"> </span><span class="si">{1}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rbins</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">rbins</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]))</span>

            <span class="n">tmpfilename</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">name</span>

        <span class="n">delete_after_use</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">tmpfilename</span><span class="p">,</span> <span class="n">delete_after_use</span>

    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Input `binfile` was not a valid array (&gt;= 1 element).&quot;</span>\
          <span class="s2">&quot;Num elements = </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rbins</span><span class="p">))</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span></div>


<div class="viewcode-block" id="fix_cz"><a class="viewcode-back" href="../../api/Corrfunc.html#Corrfunc.utils.fix_cz">[docs]</a><span class="k">def</span> <span class="nf">fix_cz</span><span class="p">(</span><span class="n">cz</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Multiplies the input array by speed of light, if the input values are</span>
<span class="sd">    too small.</span>

<span class="sd">    Essentially, converts redshift into `cz`, if the user passed</span>
<span class="sd">    redshifts instead of `cz`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    -----------</span>
<span class="sd">    cz: array-like, reals</span>
<span class="sd">       An array containing ``[Speed of Light *] redshift`` values.</span>

<span class="sd">    Returns</span>
<span class="sd">    ---------</span>
<span class="sd">    cz: array-like</span>
<span class="sd">       Actual ``cz`` values, multiplying the input ``cz`` array by the</span>
<span class="sd">       ``Speed of Light``, if ``redshift`` values were passed as input ``cz``.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># if I find that max cz is smaller than this threshold,</span>
    <span class="c1"># then I will assume z has been supplied rather than cz</span>
    <span class="n">max_cz_threshold</span> <span class="o">=</span> <span class="mf">10.0</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">input_dtype</span> <span class="o">=</span> <span class="n">cz</span><span class="o">.</span><span class="n">dtype</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Input cz array must be a numpy array&quot;</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">max</span><span class="p">(</span><span class="n">cz</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">max_cz_threshold</span><span class="p">:</span>
        <span class="n">speed_of_light</span> <span class="o">=</span> <span class="mf">299800.0</span>
        <span class="n">cz</span> <span class="o">*=</span> <span class="n">speed_of_light</span>

    <span class="k">return</span> <span class="n">cz</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">input_dtype</span><span class="p">)</span></div>


<div class="viewcode-block" id="fix_ra_dec"><a class="viewcode-back" href="../../api/Corrfunc.html#Corrfunc.utils.fix_ra_dec">[docs]</a><span class="k">def</span> <span class="nf">fix_ra_dec</span><span class="p">(</span><span class="n">ra</span><span class="p">,</span> <span class="n">dec</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wraps input RA and DEC values into range expected by the extensions.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ------------</span>
<span class="sd">    RA: array-like, units must be degrees</span>
<span class="sd">       Right Ascension values (astronomical longitude)</span>

<span class="sd">    DEC: array-like, units must be degrees</span>
<span class="sd">       Declination values (astronomical latitude)</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    Tuple (RA, DEC): array-like</span>
<span class="sd">         RA is wrapped into range [0.0, 360.0]</span>
<span class="sd">         Declination is wrapped into range [-90.0, 90.0]</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">input_dtype</span> <span class="o">=</span> <span class="n">ra</span><span class="o">.</span><span class="n">dtype</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Input RA array must be a numpy array&quot;</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">ra</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">dec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;RA or DEC must be valid arrays&quot;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">min</span><span class="p">(</span><span class="n">ra</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning: found negative RA values, wrapping into [0.0, 360.0] &quot;</span>
              <span class="s2">&quot; range&quot;</span><span class="p">)</span>
        <span class="n">ra</span> <span class="o">+=</span> <span class="mf">180.0</span>

    <span class="k">if</span> <span class="nb">max</span><span class="p">(</span><span class="n">dec</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">90.0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning: found DEC values more than 90.0; wrapping into &quot;</span>
              <span class="s2">&quot;[-90.0, 90.0] range&quot;</span><span class="p">)</span>
        <span class="n">dec</span> <span class="o">+=</span> <span class="mf">90.0</span>

    <span class="k">return</span> <span class="n">ra</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">input_dtype</span><span class="p">),</span> <span class="n">dec</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">input_dtype</span><span class="p">)</span></div>


<div class="viewcode-block" id="translate_isa_string_to_enum"><a class="viewcode-back" href="../../api/Corrfunc.html#Corrfunc.utils.translate_isa_string_to_enum">[docs]</a><span class="k">def</span> <span class="nf">translate_isa_string_to_enum</span><span class="p">(</span><span class="n">isa</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Helper function to convert an user-supplied string to the</span>
<span class="sd">    underlying enum in the C-API. The extensions only have specific</span>
<span class="sd">    implementations for AVX512F, AVX, SSE42 and FALLBACK. Any other</span>
<span class="sd">    value will raise a ValueError.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ------------</span>
<span class="sd">    isa: string</span>
<span class="sd">       A string containing the desired instruction set. Valid values are</span>
<span class="sd">       [&#39;AVX512F&#39;, &#39;AVX&#39;, &#39;SSE42&#39;, &#39;FALLBACK&#39;, &#39;FASTEST&#39;]</span>

<span class="sd">    Returns</span>
<span class="sd">    --------</span>
<span class="sd">    instruction_set: integer</span>
<span class="sd">       An integer corresponding to the desired instruction set, as used in the</span>
<span class="sd">       underlying C API. The enum used here should be defined *exactly* the</span>
<span class="sd">       same way as the enum in ``utils/defs.h``.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Input to translate_isa_string_to_enum must be &quot;</span>\
          <span class="s2">&quot;of string type. Found type = </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">isa</span><span class="p">))</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">isa</span><span class="p">,</span> <span class="n">basestring</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">NameError</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">isa</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="n">valid_isa</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;FALLBACK&#39;</span><span class="p">,</span> <span class="s1">&#39;AVX512F&#39;</span><span class="p">,</span> <span class="s1">&#39;AVX2&#39;</span><span class="p">,</span> <span class="s1">&#39;AVX&#39;</span><span class="p">,</span> <span class="s1">&#39;SSE42&#39;</span><span class="p">,</span> <span class="s1">&#39;FASTEST&#39;</span><span class="p">]</span>
    <span class="n">isa_upper</span> <span class="o">=</span> <span class="n">isa</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">isa_upper</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">valid_isa</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Desired instruction set = </span><span class="si">{0}</span><span class="s2"> is not in the list of valid &quot;</span>\
              <span class="s2">&quot;instruction sets = </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">isa</span><span class="p">,</span> <span class="n">valid_isa</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="n">enums</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;FASTEST&#39;</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
             <span class="s1">&#39;FALLBACK&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
             <span class="s1">&#39;SSE&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
             <span class="s1">&#39;SSE2&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
             <span class="s1">&#39;SSE3&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
             <span class="s1">&#39;SSSE3&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span>
             <span class="s1">&#39;SSE4&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
             <span class="s1">&#39;SSE42&#39;</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span>
             <span class="s1">&#39;AVX&#39;</span><span class="p">:</span> <span class="mi">7</span><span class="p">,</span>
             <span class="s1">&#39;AVX2&#39;</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span>
             <span class="s1">&#39;AVX512F&#39;</span><span class="p">:</span> <span class="mi">9</span>
             <span class="p">}</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">enums</span><span class="p">[</span><span class="n">isa_upper</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Do not know instruction type = </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">isa</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Valid instructions are </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">enums</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
        <span class="k">raise</span></div>


<div class="viewcode-block" id="compute_nbins"><a class="viewcode-back" href="../../api/Corrfunc.html#Corrfunc.utils.compute_nbins">[docs]</a><span class="k">def</span> <span class="nf">compute_nbins</span><span class="p">(</span><span class="n">max_diff</span><span class="p">,</span> <span class="n">binsize</span><span class="p">,</span>
                 <span class="n">refine_factor</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                 <span class="n">max_nbins</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Helper utility to find the number of bins for</span>
<span class="sd">    that satisfies the constraints of (binsize, refine_factor, and max_nbins).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ------------</span>

<span class="sd">    max_diff : double</span>
<span class="sd">       Max. difference (spatial or angular) to be spanned,</span>
<span class="sd">       (i.e., range of allowed domain values)</span>

<span class="sd">    binsize : double</span>
<span class="sd">       Min. allowed binsize (spatial or angular)</span>

<span class="sd">    refine_factor : integer, default 1</span>
<span class="sd">       How many times to refine the bins. The refinements occurs</span>
<span class="sd">       after ``nbins`` has already been determined (with ``refine_factor-1``).</span>
<span class="sd">       Thus, the number of bins will be **exactly** higher by</span>
<span class="sd">       ``refine_factor`` compared to the base case of ``refine_factor=1``</span>

<span class="sd">    max_nbins : integer, default None</span>
<span class="sd">       Max number of allowed cells</span>

<span class="sd">    Returns</span>
<span class="sd">    ---------</span>

<span class="sd">    nbins: integer, &gt;= 1</span>
<span class="sd">       Number of bins that satisfies the constraints of</span>
<span class="sd">       bin size &gt;= ``binsize``, the refinement factor</span>
<span class="sd">       and nbins &lt;= ``max_nbins``.</span>

<span class="sd">    Example</span>
<span class="sd">    ---------</span>

<span class="sd">    &gt;&gt;&gt; from Corrfunc.utils import compute_nbins</span>
<span class="sd">    &gt;&gt;&gt; max_diff = 180</span>
<span class="sd">    &gt;&gt;&gt; binsize = 10</span>
<span class="sd">    &gt;&gt;&gt; compute_nbins(max_diff, binsize)</span>
<span class="sd">    18</span>
<span class="sd">    &gt;&gt;&gt; refine_factor=2</span>
<span class="sd">    &gt;&gt;&gt; max_nbins = 20</span>
<span class="sd">    &gt;&gt;&gt; compute_nbins(max_diff, binsize, refine_factor=refine_factor,</span>
<span class="sd">    ...              max_nbins=max_nbins)</span>
<span class="sd">    20</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">max_diff</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">binsize</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Error: Invalid value for max_diff = </span><span class="si">{0}</span><span class="s1"> or binsize = </span><span class="si">{1}</span><span class="s1">. &#39;</span>\
              <span class="s1">&#39;Both must be positive&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">max_diff</span><span class="p">,</span> <span class="n">binsize</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">max_nbins</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">max_nbins</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Error: Invalid for the max. number of bins allowed = </span><span class="si">{0}</span><span class="s1">.&#39;</span>\
              <span class="s1">&#39;Max. nbins must be &gt;= 1&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">max_nbins</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">refine_factor</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Error: Refine factor must be &gt;=1. Found refine_factor = &#39;</span>\
              <span class="s1">&#39;</span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">refine_factor</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="c1"># At least 1 bin</span>
    <span class="n">ngrid</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">max_diff</span><span class="o">/</span><span class="n">binsize</span><span class="p">))</span>

    <span class="c1"># Then refine</span>
    <span class="n">ngrid</span> <span class="o">*=</span> <span class="n">refine_factor</span>

    <span class="c1"># But don&#39;t exceed max number of bins</span>
    <span class="c1"># (if passed as a parameter)</span>
    <span class="k">if</span> <span class="n">max_nbins</span><span class="p">:</span>
        <span class="n">ngrid</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">max_nbins</span><span class="p">),</span> <span class="n">ngrid</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ngrid</span></div>


<div class="viewcode-block" id="gridlink_sphere"><a class="viewcode-back" href="../../api/Corrfunc.html#Corrfunc.utils.gridlink_sphere">[docs]</a><span class="k">def</span> <span class="nf">gridlink_sphere</span><span class="p">(</span><span class="n">thetamax</span><span class="p">,</span>
                    <span class="n">ra_limits</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">dec_limits</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">link_in_ra</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">ra_refine_factor</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dec_refine_factor</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                    <span class="n">max_ra_cells</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">max_dec_cells</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span>
                    <span class="n">return_num_ra_cells</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">input_in_degrees</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A method to optimally partition spherical regions such that pairs of</span>
<span class="sd">    points within a certain angular separation, ``thetamax``, can be quickly</span>
<span class="sd">    computed.</span>

<span class="sd">    Generates the  binning scheme used in :py:mod:`Corrfunc.mocks.DDtheta_mocks`</span>
<span class="sd">    for a spherical region in Right Ascension (RA), Declination (DEC)</span>
<span class="sd">    and a maximum angular separation.</span>

<span class="sd">    For a given ``thetamax``, regions on the sphere are divided into bands</span>
<span class="sd">    in DEC bands, with the width in DEC equal to ``thetamax``. If</span>
<span class="sd">    ``link_in_ra`` is set, then these DEC bands are further sub-divided</span>
<span class="sd">    into RA cells.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    thetamax : double</span>
<span class="sd">       Max. angular separation of pairs. Expected to be in degrees</span>
<span class="sd">       unless ``input_in_degrees`` is set to ``False``.</span>

<span class="sd">    ra_limits : array of 2 doubles. Default [0.0, 2*pi]</span>
<span class="sd">       Range of Righ Ascension (longitude) for the spherical region</span>

<span class="sd">    dec_limits : array of 2 doubles. Default [-pi/2, pi/2]</span>
<span class="sd">       Range of Declination (latitude) values for the spherical region</span>

<span class="sd">    link_in_ra : Boolean. Default True</span>
<span class="sd">       Whether linking in RA is done (in addition to linking in DEC)</span>

<span class="sd">    ra_refine_factor : integer, &gt;= 1. Default 1</span>
<span class="sd">       Controls the sub-division of the RA cells. For a large number of</span>
<span class="sd">       particles, higher `ra_refine_factor` typically results in a faster</span>
<span class="sd">       runtime</span>

<span class="sd">    dec_refine_factor : integer, &gt;= 1. Default 1</span>
<span class="sd">       Controls the sub-division of the DEC cells. For a large number of</span>
<span class="sd">       particles, higher `dec_refine_factor` typically results in a faster</span>
<span class="sd">       runtime</span>

<span class="sd">    max_ra_cells : integer, &gt;= 1. Default 100</span>
<span class="sd">       The max. number of RA cells **per DEC band**.</span>

<span class="sd">    max_dec_cells : integer &gt;= 1. Default 200</span>
<span class="sd">       The max. number of total DEC bands</span>

<span class="sd">    return_num_ra_cells: bool, default False</span>
<span class="sd">       Flag to return the number of RA cells per DEC band</span>

<span class="sd">    input_in_degrees : Boolean. Default True</span>
<span class="sd">       Flag to show if the input quantities are in degrees. If set to</span>
<span class="sd">       False, all angle inputs will be taken to be in radians.</span>

<span class="sd">    Returns</span>
<span class="sd">    ---------</span>

<span class="sd">    sphere_grid : A numpy compound array, shape (ncells, 2)</span>
<span class="sd">       A numpy compound array with fields ``dec_limit`` and ``ra_limit`` of</span>
<span class="sd">       size 2 each. These arrays contain the beginning and end of DEC</span>
<span class="sd">       and RA regions for the cell.</span>

<span class="sd">    num_ra_cells: numpy array, returned if ``return_num_ra_cells`` is set</span>
<span class="sd">       A numpy array containing the number of RA cells per declination band</span>


<span class="sd">    .. note:: If ``link_in_ra=False``, then there is effectively one RA bin</span>
<span class="sd">       per DEC band. The  &#39;ra_limit&#39; field will show the range of allowed</span>
<span class="sd">       RA values.</span>


<span class="sd">    .. seealso:: :py:mod:`Corrfunc.mocks.DDtheta_mocks`</span>

<span class="sd">    Example</span>
<span class="sd">    --------</span>

<span class="sd">    &gt;&gt;&gt; from Corrfunc.utils import gridlink_sphere</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; try:  # Backwards compatibility with old Numpy print formatting</span>
<span class="sd">    ...     np.set_printoptions(legacy=&#39;1.13&#39;)</span>
<span class="sd">    ... except TypeError:</span>
<span class="sd">    ...     pass</span>
<span class="sd">    &gt;&gt;&gt; thetamax=30</span>
<span class="sd">    &gt;&gt;&gt; grid = gridlink_sphere(thetamax)</span>
<span class="sd">    &gt;&gt;&gt; print(grid)  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">    [([-1.57079633, -1.04719755], [ 0.        ,  3.14159265])</span>
<span class="sd">     ([-1.57079633, -1.04719755], [ 3.14159265,  6.28318531])</span>
<span class="sd">     ([-1.04719755, -0.52359878], [ 0.        ,  3.14159265])</span>
<span class="sd">     ([-1.04719755, -0.52359878], [ 3.14159265,  6.28318531])</span>
<span class="sd">     ([-0.52359878,  0.        ], [ 0.        ,  1.25663706])</span>
<span class="sd">     ([-0.52359878,  0.        ], [ 1.25663706,  2.51327412])</span>
<span class="sd">     ([-0.52359878,  0.        ], [ 2.51327412,  3.76991118])</span>
<span class="sd">     ([-0.52359878,  0.        ], [ 3.76991118,  5.02654825])</span>
<span class="sd">     ([-0.52359878,  0.        ], [ 5.02654825,  6.28318531])</span>
<span class="sd">     ([ 0.        ,  0.52359878], [ 0.        ,  1.25663706])</span>
<span class="sd">     ([ 0.        ,  0.52359878], [ 1.25663706,  2.51327412])</span>
<span class="sd">     ([ 0.        ,  0.52359878], [ 2.51327412,  3.76991118])</span>
<span class="sd">     ([ 0.        ,  0.52359878], [ 3.76991118,  5.02654825])</span>
<span class="sd">     ([ 0.        ,  0.52359878], [ 5.02654825,  6.28318531])</span>
<span class="sd">     ([ 0.52359878,  1.04719755], [ 0.        ,  3.14159265])</span>
<span class="sd">     ([ 0.52359878,  1.04719755], [ 3.14159265,  6.28318531])</span>
<span class="sd">     ([ 1.04719755,  1.57079633], [ 0.        ,  3.14159265])</span>
<span class="sd">     ([ 1.04719755,  1.57079633], [ 3.14159265,  6.28318531])]</span>
<span class="sd">    &gt;&gt;&gt; grid = gridlink_sphere(60, dec_refine_factor=3, ra_refine_factor=2)</span>
<span class="sd">    &gt;&gt;&gt; print(grid)  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">    [([-1.57079633, -1.22173048], [ 0.        ,  1.57079633])</span>
<span class="sd">     ([-1.57079633, -1.22173048], [ 1.57079633,  3.14159265])</span>
<span class="sd">     ([-1.57079633, -1.22173048], [ 3.14159265,  4.71238898])</span>
<span class="sd">     ([-1.57079633, -1.22173048], [ 4.71238898,  6.28318531])</span>
<span class="sd">     ([-1.22173048, -0.87266463], [ 0.        ,  1.57079633])</span>
<span class="sd">     ([-1.22173048, -0.87266463], [ 1.57079633,  3.14159265])</span>
<span class="sd">     ([-1.22173048, -0.87266463], [ 3.14159265,  4.71238898])</span>
<span class="sd">     ([-1.22173048, -0.87266463], [ 4.71238898,  6.28318531])</span>
<span class="sd">     ([-0.87266463, -0.52359878], [ 0.        ,  1.57079633])</span>
<span class="sd">     ([-0.87266463, -0.52359878], [ 1.57079633,  3.14159265])</span>
<span class="sd">     ([-0.87266463, -0.52359878], [ 3.14159265,  4.71238898])</span>
<span class="sd">     ([-0.87266463, -0.52359878], [ 4.71238898,  6.28318531])</span>
<span class="sd">     ([-0.52359878, -0.17453293], [ 0.        ,  1.57079633])</span>
<span class="sd">     ([-0.52359878, -0.17453293], [ 1.57079633,  3.14159265])</span>
<span class="sd">     ([-0.52359878, -0.17453293], [ 3.14159265,  4.71238898])</span>
<span class="sd">     ([-0.52359878, -0.17453293], [ 4.71238898,  6.28318531])</span>
<span class="sd">     ([-0.17453293,  0.17453293], [ 0.        ,  1.57079633])</span>
<span class="sd">     ([-0.17453293,  0.17453293], [ 1.57079633,  3.14159265])</span>
<span class="sd">     ([-0.17453293,  0.17453293], [ 3.14159265,  4.71238898])</span>
<span class="sd">     ([-0.17453293,  0.17453293], [ 4.71238898,  6.28318531])</span>
<span class="sd">     ([ 0.17453293,  0.52359878], [ 0.        ,  1.57079633])</span>
<span class="sd">     ([ 0.17453293,  0.52359878], [ 1.57079633,  3.14159265])</span>
<span class="sd">     ([ 0.17453293,  0.52359878], [ 3.14159265,  4.71238898])</span>
<span class="sd">     ([ 0.17453293,  0.52359878], [ 4.71238898,  6.28318531])</span>
<span class="sd">     ([ 0.52359878,  0.87266463], [ 0.        ,  1.57079633])</span>
<span class="sd">     ([ 0.52359878,  0.87266463], [ 1.57079633,  3.14159265])</span>
<span class="sd">     ([ 0.52359878,  0.87266463], [ 3.14159265,  4.71238898])</span>
<span class="sd">     ([ 0.52359878,  0.87266463], [ 4.71238898,  6.28318531])</span>
<span class="sd">     ([ 0.87266463,  1.22173048], [ 0.        ,  1.57079633])</span>
<span class="sd">     ([ 0.87266463,  1.22173048], [ 1.57079633,  3.14159265])</span>
<span class="sd">     ([ 0.87266463,  1.22173048], [ 3.14159265,  4.71238898])</span>
<span class="sd">     ([ 0.87266463,  1.22173048], [ 4.71238898,  6.28318531])</span>
<span class="sd">     ([ 1.22173048,  1.57079633], [ 0.        ,  1.57079633])</span>
<span class="sd">     ([ 1.22173048,  1.57079633], [ 1.57079633,  3.14159265])</span>
<span class="sd">     ([ 1.22173048,  1.57079633], [ 3.14159265,  4.71238898])</span>
<span class="sd">     ([ 1.22173048,  1.57079633], [ 4.71238898,  6.28318531])]</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">radians</span><span class="p">,</span> <span class="n">pi</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>


    <span class="k">if</span> <span class="n">input_in_degrees</span><span class="p">:</span>
        <span class="n">thetamax</span> <span class="o">=</span> <span class="n">radians</span><span class="p">(</span><span class="n">thetamax</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ra_limits</span><span class="p">:</span>
            <span class="n">ra_limits</span> <span class="o">=</span> <span class="p">[</span><span class="n">radians</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ra_limits</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">dec_limits</span><span class="p">:</span>
            <span class="n">dec_limits</span> <span class="o">=</span> <span class="p">[</span><span class="n">radians</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">dec_limits</span><span class="p">]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">ra_limits</span><span class="p">:</span>
        <span class="n">ra_limits</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">pi</span><span class="p">]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">dec_limits</span><span class="p">:</span>
        <span class="n">dec_limits</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="n">pi</span><span class="p">,</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">pi</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">dec_limits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">dec_limits</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Declination limits should be sorted in increasing &#39;</span>\
              <span class="s1">&#39;order. However, dec_limits = [</span><span class="si">{0}</span><span class="s1">, </span><span class="si">{1}</span><span class="s1">] is not&#39;</span><span class="o">.</span>\
              <span class="nb">format</span><span class="p">(</span><span class="n">dec_limits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dec_limits</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">ra_limits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">ra_limits</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Declination limits should be sorted in increasing &#39;</span>\
              <span class="s1">&#39;order. However, ra_limits = [</span><span class="si">{0}</span><span class="s1">, </span><span class="si">{1}</span><span class="s1">] is not&#39;</span><span class="o">.</span>\
              <span class="nb">format</span><span class="p">(</span><span class="n">ra_limits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ra_limits</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">dec_limits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="n">pi</span> <span class="ow">or</span> <span class="n">dec_limits</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">pi</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Valid range of values for declination are [-pi/2, +pi/2] deg. &#39;</span>\
              <span class="s1">&#39;However, dec_limits = [</span><span class="si">{0}</span><span class="s1">, </span><span class="si">{1}</span><span class="s1">] does not fall within that &#39;</span>\
              <span class="s1">&#39;range&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dec_limits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dec_limits</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">ra_limits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">0.0</span> <span class="ow">or</span> <span class="n">ra_limits</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">pi</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Valid range of values for declination are [0.0, 2*pi] deg. &#39;</span>\
              <span class="s1">&#39;However, ra_limits = [</span><span class="si">{0}</span><span class="s1">, </span><span class="si">{1}</span><span class="s1">] does not fall within that &#39;</span>\
              <span class="s1">&#39;range&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ra_limits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ra_limits</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="n">dec_diff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dec_limits</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">dec_limits</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">ngrid_dec</span> <span class="o">=</span> <span class="n">compute_nbins</span><span class="p">(</span><span class="n">dec_diff</span><span class="p">,</span> <span class="n">thetamax</span><span class="p">,</span>
                             <span class="n">refine_factor</span><span class="o">=</span><span class="n">dec_refine_factor</span><span class="p">,</span>
                             <span class="n">max_nbins</span><span class="o">=</span><span class="n">max_dec_cells</span><span class="p">)</span>

    <span class="n">dec_binsize</span> <span class="o">=</span> <span class="n">dec_diff</span><span class="o">/</span><span class="n">ngrid_dec</span>

    <span class="c1"># Upper and lower limits of the declination bands</span>
    <span class="n">grid_dtype</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">({</span><span class="s1">&#39;names&#39;</span><span class="p">:[</span><span class="s1">&#39;dec_limit&#39;</span><span class="p">,</span><span class="s1">&#39;ra_limit&#39;</span><span class="p">],</span>
                          <span class="s1">&#39;formats&#39;</span><span class="p">:[(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="p">)),</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="p">))]</span>
    <span class="p">})</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">link_in_ra</span><span class="p">:</span>
        <span class="n">sphere_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ngrid_dec</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">grid_dtype</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sphere_grid</span><span class="p">[</span><span class="s1">&#39;dec_limit&#39;</span><span class="p">]):</span>
            <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">dec_limits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="n">dec_binsize</span>
            <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">dec_limits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">dec_binsize</span>

        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">sphere_grid</span><span class="p">[</span><span class="s1">&#39;ra_limit&#39;</span><span class="p">]:</span>
            <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ra_limits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ra_limits</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">sphere_grid</span>

    <span class="c1"># RA linking is requested</span>
    <span class="n">ra_diff</span> <span class="o">=</span> <span class="n">ra_limits</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">ra_limits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">sin_half_thetamax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">thetamax</span><span class="p">)</span>

    <span class="n">totncells</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">num_ra_cells</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ngrid_dec</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
    <span class="n">num_ra_cells</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">ra_refine_factor</span>
    <span class="c1"># xrange is replaced by range for python3</span>
    <span class="c1"># by using a try/except at the top</span>
    <span class="k">for</span> <span class="n">idec</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">ngrid_dec</span><span class="p">):</span>
        <span class="n">dec_min</span> <span class="o">=</span> <span class="n">dec_limits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">idec</span><span class="o">*</span><span class="n">dec_binsize</span>
        <span class="n">dec_max</span> <span class="o">=</span> <span class="n">dec_min</span> <span class="o">+</span> <span class="n">dec_binsize</span>

        <span class="n">cos_dec_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">dec_min</span><span class="p">)</span>
        <span class="n">cos_dec_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">dec_max</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">cos_dec_min</span> <span class="o">&lt;</span> <span class="n">cos_dec_max</span><span class="p">:</span>
            <span class="n">min_cos</span> <span class="o">=</span> <span class="n">cos_dec_min</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">min_cos</span> <span class="o">=</span> <span class="n">cos_dec_max</span>

        <span class="k">if</span> <span class="n">min_cos</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_tmp</span> <span class="o">=</span> <span class="n">sin_half_thetamax</span><span class="o">/</span><span class="n">min_cos</span>
            <span class="c1"># clamp to range [0.0, 1.0]</span>
            <span class="n">_tmp</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">_tmp</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">)</span>
            <span class="n">ra_binsize</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="n">_tmp</span><span class="p">),</span> <span class="n">ra_diff</span><span class="p">)</span>
            <span class="n">num_ra_cells</span><span class="p">[</span><span class="n">idec</span><span class="p">]</span> <span class="o">=</span> <span class="n">compute_nbins</span><span class="p">(</span><span class="n">ra_diff</span><span class="p">,</span> <span class="n">ra_binsize</span><span class="p">,</span>
                                              <span class="n">refine_factor</span><span class="o">=</span><span class="n">ra_refine_factor</span><span class="p">,</span>
                                              <span class="n">max_nbins</span><span class="o">=</span><span class="n">max_ra_cells</span><span class="p">)</span>

    <span class="n">totncells</span> <span class="o">=</span> <span class="n">num_ra_cells</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">sphere_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">totncells</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">grid_dtype</span><span class="p">)</span>
    <span class="n">ra_binsizes</span> <span class="o">=</span> <span class="n">ra_diff</span><span class="o">/</span><span class="n">num_ra_cells</span>

    <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">idec</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">ngrid_dec</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">start</span> <span class="o">+</span> <span class="n">num_ra_cells</span><span class="p">[</span><span class="n">idec</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">totncells</span>
        <span class="n">source_sel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">start</span><span class="o">+</span><span class="n">num_ra_cells</span><span class="p">[</span><span class="n">idec</span><span class="p">]]</span>
        <span class="k">for</span> <span class="n">ira</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sphere_grid</span><span class="p">[</span><span class="n">source_sel</span><span class="p">]):</span>
            <span class="n">r</span><span class="p">[</span><span class="s1">&#39;dec_limit&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">dec_limits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">dec_binsize</span><span class="o">*</span><span class="n">idec</span>
            <span class="n">r</span><span class="p">[</span><span class="s1">&#39;dec_limit&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">dec_limits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">dec_binsize</span><span class="o">*</span><span class="p">(</span><span class="n">idec</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">r</span><span class="p">[</span><span class="s1">&#39;ra_limit&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ra_limits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">ra_binsizes</span><span class="p">[</span><span class="n">idec</span><span class="p">]</span> <span class="o">*</span> <span class="n">ira</span>
            <span class="n">r</span><span class="p">[</span><span class="s1">&#39;ra_limit&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ra_limits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">ra_binsizes</span><span class="p">[</span><span class="n">idec</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">ira</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">start</span> <span class="o">+=</span> <span class="n">num_ra_cells</span><span class="p">[</span><span class="n">idec</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">return_num_ra_cells</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">sphere_grid</span><span class="p">,</span> <span class="n">num_ra_cells</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">sphere_grid</span></div>


<span class="k">def</span> <span class="nf">convert_to_native_endian</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">warn</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Returns the supplied array in native endian byte-order.</span>
<span class="sd">    If the array already has native endianness, then the</span>
<span class="sd">    same array is returned.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    array: np.ndarray</span>
<span class="sd">        The array to convert</span>
<span class="sd">    warn: bool, optional</span>
<span class="sd">        Print a warning if `array` is not already native endian.</span>
<span class="sd">        Default: False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    new_array: np.ndarray</span>
<span class="sd">        The array in native-endian byte-order.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; import sys</span>
<span class="sd">    &gt;&gt;&gt; sys_is_le = sys.byteorder == &#39;little&#39;</span>
<span class="sd">    &gt;&gt;&gt; native_code = sys_is_le and &#39;&lt;&#39; or &#39;&gt;&#39;</span>
<span class="sd">    &gt;&gt;&gt; swapped_code = sys_is_le and &#39;&gt;&#39; or &#39;&lt;&#39;</span>
<span class="sd">    &gt;&gt;&gt; native_dt = np.dtype(native_code + &#39;i4&#39;)</span>
<span class="sd">    &gt;&gt;&gt; swapped_dt = np.dtype(swapped_code + &#39;i4&#39;)</span>
<span class="sd">    &gt;&gt;&gt; arr = np.arange(10, dtype=native_dt)</span>
<span class="sd">    &gt;&gt;&gt; new_arr = convert_to_native_endian(arr)</span>
<span class="sd">    &gt;&gt;&gt; arr is new_arr</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; arr = np.arange(10, dtype=swapped_dt)</span>
<span class="sd">    &gt;&gt;&gt; new_arr = convert_to_native_endian(arr)</span>
<span class="sd">    &gt;&gt;&gt; new_arr.dtype.byteorder == &#39;=&#39; or new_arr.dtype.byteorder == native_code</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; convert_to_native_endian(None) is None</span>
<span class="sd">    True</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="kn">import</span> <span class="nn">warnings</span>

    <span class="k">if</span> <span class="n">array</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">array</span>

    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
    <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>

    <span class="n">system_is_little_endian</span> <span class="o">=</span> <span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">byteorder</span> <span class="o">==</span> <span class="s1">&#39;little&#39;</span><span class="p">)</span>
    <span class="n">array_is_little_endian</span> <span class="o">=</span> <span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">byteorder</span> <span class="o">==</span> <span class="s1">&#39;&lt;&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">array_is_little_endian</span> <span class="o">!=</span> <span class="n">system_is_little_endian</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">byteorder</span> <span class="o">==</span> <span class="s1">&#39;=&#39;</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">warn</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;One or more input array has non-native endianness!  A copy will&quot;</span>\
                      <span class="s2">&quot; be made with the correct endianness.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">array</span><span class="o">.</span><span class="n">byteswap</span><span class="p">()</span><span class="o">.</span><span class="n">newbyteorder</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">array</span>

<span class="k">def</span> <span class="nf">is_native_endian</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Checks whether the given array is native-endian.</span>
<span class="sd">    None evaluates to True.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    array: np.ndarray</span>
<span class="sd">        The array to check</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    is_native: bool</span>
<span class="sd">        Whether the endianness is native</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; import sys</span>
<span class="sd">    &gt;&gt;&gt; sys_is_le = sys.byteorder == &#39;little&#39;</span>
<span class="sd">    &gt;&gt;&gt; native_code = sys_is_le and &#39;&lt;&#39; or &#39;&gt;&#39;</span>
<span class="sd">    &gt;&gt;&gt; swapped_code = sys_is_le and &#39;&gt;&#39; or &#39;&lt;&#39;</span>
<span class="sd">    &gt;&gt;&gt; native_dt = np.dtype(native_code + &#39;i4&#39;)</span>
<span class="sd">    &gt;&gt;&gt; swapped_dt = np.dtype(swapped_code + &#39;i4&#39;)</span>
<span class="sd">    &gt;&gt;&gt; arr = np.arange(10, dtype=native_dt)</span>
<span class="sd">    &gt;&gt;&gt; is_native_endian(arr)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; arr = np.arange(10, dtype=swapped_dt)</span>
<span class="sd">    &gt;&gt;&gt; is_native_endian(arr)</span>
<span class="sd">    False</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">if</span> <span class="n">array</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
    <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>

    <span class="n">system_is_little_endian</span> <span class="o">=</span> <span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">byteorder</span> <span class="o">==</span> <span class="s1">&#39;little&#39;</span><span class="p">)</span>
    <span class="n">array_is_little_endian</span> <span class="o">=</span> <span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">byteorder</span> <span class="o">==</span> <span class="s1">&#39;&lt;&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">array_is_little_endian</span> <span class="o">==</span> <span class="n">system_is_little_endian</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">byteorder</span> <span class="o">==</span> <span class="s1">&#39;=&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">process_weights</span><span class="p">(</span><span class="n">weights1</span><span class="p">,</span> <span class="n">weights2</span><span class="p">,</span> <span class="n">X1</span><span class="p">,</span> <span class="n">X2</span><span class="p">,</span> <span class="n">weight_type</span><span class="p">,</span> <span class="n">autocorr</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Process the user-passed weights in a manner that can be handled by</span>
<span class="sd">    the C code.  `X1` and `X2` are the corresponding pos arrays; they</span>
<span class="sd">    allow us to get the appropriate dtype and length when weight arrays</span>
<span class="sd">    are not explicitly given.</span>

<span class="sd">    1) Scalar weights are promoted to arrays</span>
<span class="sd">    2) If only one set of weights is given, the other is generated with</span>
<span class="sd">        weights = 1, but only for weight_type = &#39;pair_product&#39;.  Otherwise</span>
<span class="sd">        a ValueError will be raised.</span>
<span class="sd">    3) Weight arrays are reshaped to 2D (shape n_weights_per_particle, n_particles)</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

    <span class="k">if</span> <span class="n">weight_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Weights will not be used; do nothing</span>
        <span class="k">return</span> <span class="n">weights1</span><span class="p">,</span> <span class="n">weights2</span>

    <span class="c1"># Takes a scalar, 1d, or 2d weights array</span>
    <span class="c1"># and returns a 2d array of shape (nweights,npart)</span>
    <span class="k">def</span> <span class="nf">prep</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">x</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">w</span>

        <span class="c1"># not None, so probably float or numpy array</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
            <span class="c1"># Use the particle dtype if a Python float was given</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>  <span class="c1"># could have been numpy scalar</span>

        <span class="c1"># If only one particle&#39;s weight(s) were given,</span>
        <span class="c1"># assume it applies to all particles</span>
        <span class="k">if</span> <span class="n">w</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

        <span class="c1"># now of shape (nweights,nparticles)</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">w</span>

    <span class="n">weights1</span> <span class="o">=</span> <span class="n">prep</span><span class="p">(</span><span class="n">weights1</span><span class="p">,</span> <span class="n">X1</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">autocorr</span><span class="p">:</span>
        <span class="n">weights2</span> <span class="o">=</span> <span class="n">prep</span><span class="p">(</span><span class="n">weights2</span><span class="p">,</span> <span class="n">X2</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">weights1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="n">weights2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">weight_type</span> <span class="o">!=</span> <span class="s1">&#39;pair_product&#39;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;If using a weight_type other than &quot;</span>\
                                 <span class="s2">&quot;&#39;pair_product&#39;, you must provide &quot;</span>\
                                 <span class="s2">&quot;both weight arrays.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">weights1</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">weights2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">weights1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">weights2</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">X1</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">X1</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">weights2</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">weights1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">weights2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">weights1</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">X2</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">X2</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">weights1</span><span class="p">,</span> <span class="n">weights2</span>


<span class="nd">@contextmanager</span>
<span class="k">def</span> <span class="nf">sys_pipes</span><span class="p">():</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    We can use the Wurlitzer package to redirect stdout and stderr</span>
<span class="sd">    from the command line into a Jupyter notebook.  But if we&#39;re not</span>
<span class="sd">    in a notebook, this isn&#39;t safe because we can&#39;t redirect stdout</span>
<span class="sd">    to itself.  This function is a thin wrapper that checks if the</span>
<span class="sd">    stdout/err streams are TTYs and enables output redirection</span>
<span class="sd">    based on that.</span>

<span class="sd">    Basic usage is:</span>

<span class="sd">    &gt;&gt;&gt; with sys_pipes():  # doctest: +SKIP</span>
<span class="sd">    ...    call_some_c_function()</span>

<span class="sd">    See the Wurlitzer package for usage of `wurlitzer.pipes()`;</span>
<span class="sd">    see also https://github.com/manodeep/Corrfunc/issues/157.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;stdout&#39;</span><span class="p">:</span><span class="kc">None</span> <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">isatty</span><span class="p">()</span> <span class="k">else</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">,</span>
              <span class="s1">&#39;stderr&#39;</span><span class="p">:</span><span class="kc">None</span> <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">isatty</span><span class="p">()</span> <span class="k">else</span> <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span> <span class="p">}</span>

    <span class="c1"># Redirection might break for any number of reasons, like</span>
    <span class="c1"># stdout/err already being closed/redirected.  We probably</span>
    <span class="c1"># prefer not to crash in that case and instead continue</span>
    <span class="c1"># without any redirection.</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">with</span> <span class="n">wurlitzer</span><span class="o">.</span><span class="n">pipes</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="k">yield</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">yield</span>


<div class="viewcode-block" id="compute_amps"><a class="viewcode-back" href="../../api/smoothmodules.html#Corrfunc.utils.compute_amps">[docs]</a><span class="k">def</span> <span class="nf">compute_amps</span><span class="p">(</span><span class="n">nprojbins</span><span class="p">,</span> <span class="n">nd1</span><span class="p">,</span> <span class="n">nd2</span><span class="p">,</span> <span class="n">nr1</span><span class="p">,</span> <span class="n">nr2</span><span class="p">,</span> <span class="n">dd</span><span class="p">,</span> <span class="n">dr</span><span class="p">,</span> <span class="n">rd</span><span class="p">,</span> <span class="n">rr</span><span class="p">,</span> <span class="n">qq</span><span class="p">):</span>
    <span class="c1">#TODO: make second dataset parameters optional</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Compute the amplitude vector for the continuous correlation function from the component vectors (a.k.a. pair counts in a given basis).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nprojbins : int</span>
<span class="sd">       Number of basis functions</span>

<span class="sd">    nd1 : int</span>
<span class="sd">       Number of particles in data catalog 1</span>

<span class="sd">    nd2 : int</span>
<span class="sd">       Number of particles in data catalog 2</span>

<span class="sd">    nr1 : int</span>
<span class="sd">       Number of particles in random1</span>

<span class="sd">    nr2 : int</span>
<span class="sd">       Number of particles in random2</span>

<span class="sd">    dd: array-like, double</span>
<span class="sd">       Component vector for data-data cross-correlation</span>

<span class="sd">    dr: array-like, double</span>
<span class="sd">       Component vector for data-random cross-correlation</span>

<span class="sd">    rd: array-like, double</span>
<span class="sd">       Component vector for random-data cross-correlation</span>

<span class="sd">    rr: array-like, double</span>
<span class="sd">       Component vector for random-random cross-correlation</span>

<span class="sd">    qq: array-like, double</span>
<span class="sd">       Component tensor for random-random cross-correlation</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    amps: array-like, double</span>
<span class="sd">        Vector of amplitudes, with length nprojbins</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">Corrfunc._countpairs_mocks</span> <span class="kn">import</span> <span class="n">convert_3d_proj_counts_to_amplitude</span> <span class="k">as</span> \
            <span class="n">amp_extn</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Could not import the C extension for computing amplitudes.&quot;</span>
        <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
    <span class="kn">from</span> <span class="nn">Corrfunc.utils</span> <span class="kn">import</span> <span class="n">sys_pipes</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Computing amplitudes (Corrfunc/utils.py)&#39;</span><span class="p">)</span>
    <span class="k">with</span> <span class="n">sys_pipes</span><span class="p">():</span>
        <span class="n">amps</span> <span class="o">=</span> <span class="n">amp_extn</span><span class="p">(</span><span class="n">nprojbins</span><span class="p">,</span> <span class="n">nd1</span><span class="p">,</span> <span class="n">nd2</span><span class="p">,</span> <span class="n">nr1</span><span class="p">,</span> <span class="n">nr2</span><span class="p">,</span> <span class="n">dd</span><span class="p">,</span> <span class="n">dr</span><span class="p">,</span> <span class="n">rd</span><span class="p">,</span> <span class="n">rr</span><span class="p">,</span> <span class="n">qq</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">amps</span><span class="p">)</span></div>


<div class="viewcode-block" id="evaluate_xi"><a class="viewcode-back" href="../../api/smoothmodules.html#Corrfunc.utils.evaluate_xi">[docs]</a><span class="k">def</span> <span class="nf">evaluate_xi</span><span class="p">(</span><span class="n">amps</span><span class="p">,</span> <span class="n">rvals</span><span class="p">,</span> <span class="n">proj_type</span><span class="p">,</span> <span class="n">rbins</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">projfn</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Evaluate the correlation function for the given amplitudes and separation values.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    amps : array-like, double</span>
<span class="sd">       Vector of amplitudes, e.g. that returned by compute_amps</span>

<span class="sd">    rvals : array-like, double</span>
<span class="sd">       Array of radial separation values at which to evaluate the correlation function</span>

<span class="sd">    proj_type : string</span>
<span class="sd">       Projection method to use; currently supported methods are [&#39;tophat&#39;, &#39;piecewise&#39;, &#39;generalr&#39;, &#39;gaussian_kernel&#39;]</span>

<span class="sd">    rbins : array-like, double, default=None</span>
<span class="sd">        Bin edges for tophat or piecewise bases (or custom basis)</span>

<span class="sd">    projfn : string, default=None</span>
<span class="sd">       Filename of projection file; necessary for proj_type=&#39;generalr&#39;</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    xi: array-like, double</span>
<span class="sd">        Vector of xi values, same shape as rvals</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">Corrfunc._countpairs_mocks</span> <span class="kn">import</span> <span class="n">evaluate_xi</span> <span class="k">as</span> \
            <span class="n">eval_extn</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Could not import the C extension for computing amplitudes.&quot;</span>
        <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
    <span class="kn">from</span> <span class="nn">Corrfunc.utils</span> <span class="kn">import</span> <span class="n">sys_pipes</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">proj_type</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Cannot pass a null project type to evaluate_xi&quot;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="c1"># Will need these in C code, easier to calculate here and pass</span>
    <span class="n">nprojbins</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">amps</span><span class="p">)</span>
    <span class="n">nrvals</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">rvals</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">rbins</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">nrbins</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">rbins</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">nrbins</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="c1"># Passing None parameters breaks the parsing code, so avoid this</span>
    <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;projfn&#39;</span><span class="p">,</span> <span class="s1">&#39;nrbins&#39;</span><span class="p">,</span> <span class="s1">&#39;rbins&#39;</span><span class="p">]:</span>
        <span class="n">v</span> <span class="o">=</span> <span class="nb">locals</span><span class="p">()[</span><span class="n">k</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Evaluating xi (Corrfunc/utils.py)&#39;</span><span class="p">)</span>
    <span class="k">with</span> <span class="n">sys_pipes</span><span class="p">():</span>
        <span class="n">xi</span> <span class="o">=</span> <span class="n">eval_extn</span><span class="p">(</span><span class="n">nprojbins</span><span class="p">,</span> <span class="n">amps</span><span class="p">,</span> <span class="n">nrvals</span><span class="p">,</span> <span class="n">rvals</span><span class="p">,</span> <span class="n">proj_type</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span></div>


<span class="c1"># may not need nsbins and sbins</span>
<div class="viewcode-block" id="qq_analytic"><a class="viewcode-back" href="../../api/smoothmodules.html#Corrfunc.utils.qq_analytic">[docs]</a><span class="k">def</span> <span class="nf">qq_analytic</span><span class="p">(</span><span class="n">rmin</span><span class="p">,</span> <span class="n">rmax</span><span class="p">,</span> <span class="n">nd</span><span class="p">,</span> <span class="n">volume</span><span class="p">,</span> <span class="n">nprojbins</span><span class="p">,</span> <span class="n">proj_type</span><span class="p">,</span> <span class="n">rbins</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">projfn</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Compute the QQ tensor analytically for a periodic box, for the given set of basis functions.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    rmin : double</span>
<span class="sd">        Minimum r-value for integration </span>

<span class="sd">    rmax : double</span>
<span class="sd">        Maximum r-value for integration </span>

<span class="sd">    nd : int</span>
<span class="sd">        Number of points in data catalog</span>

<span class="sd">    volume : double</span>
<span class="sd">        Volume of data cube, in the same units as the r-values (cubed)</span>
<span class="sd">    </span>
<span class="sd">    nprojbins : int</span>
<span class="sd">       Number of basis functions</span>

<span class="sd">    proj_type : string</span>
<span class="sd">       Projection method to use; currently supported methods are [&#39;tophat&#39;, &#39;piecewise&#39;, &#39;generalr&#39;, &#39;gaussian_kernel&#39;]</span>

<span class="sd">    rbins : array-like, double, default=None</span>
<span class="sd">       Edges of r-bins for tophat or piecewise projections</span>

<span class="sd">    projfn : string, default=None</span>
<span class="sd">       Filename of projection file if necessary</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    qq: array-like, double</span>
<span class="sd">        Tensor of QQ values, with size (nprojbins, nprojbins) </span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">Corrfunc._countpairs_mocks</span> <span class="kn">import</span> <span class="n">qq_analytic</span> <span class="k">as</span> \
            <span class="n">eval_extn</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Could not import the C extension for computing QQ analytically.&quot;</span>
        <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
    <span class="kn">from</span> <span class="nn">Corrfunc.utils</span> <span class="kn">import</span> <span class="n">sys_pipes</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">proj_type</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Cannot pass a null project type to qq_analytic&quot;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="c1"># TODO: proper way/place to typecheck and cast?</span>
    <span class="n">rmin</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">rmin</span><span class="p">)</span>
    <span class="n">rmax</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">rmax</span><span class="p">)</span> <span class="c1">#breaks if passed as int</span>
    <span class="n">nd</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">nd</span><span class="p">)</span>
    <span class="n">volume</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">volume</span><span class="p">)</span>
    <span class="n">nprojbins</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">nprojbins</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">rbins</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">nrbins</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">rbins</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">nrbins</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="c1"># Passing None parameters breaks the parsing code, so avoid this</span>
    <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;projfn&#39;</span><span class="p">,</span> <span class="s1">&#39;nrbins&#39;</span><span class="p">,</span> <span class="s1">&#39;rbins&#39;</span><span class="p">]:</span>
        <span class="n">v</span> <span class="o">=</span> <span class="nb">locals</span><span class="p">()[</span><span class="n">k</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Evaluating qq_analytic (Corrfunc/utils.py)&#39;</span><span class="p">)</span>

    <span class="k">with</span> <span class="n">sys_pipes</span><span class="p">():</span>
        <span class="n">extn_results</span> <span class="o">=</span> <span class="n">eval_extn</span><span class="p">(</span><span class="n">rmin</span><span class="p">,</span> <span class="n">rmax</span><span class="p">,</span> <span class="n">nd</span><span class="p">,</span> <span class="n">volume</span><span class="p">,</span> <span class="n">nprojbins</span><span class="p">,</span> <span class="n">proj_type</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">extn_results</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;RuntimeError occurred&quot;</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">rr</span><span class="p">,</span> <span class="n">qq</span> <span class="o">=</span> <span class="n">extn_results</span>

    <span class="n">qq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">qq</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">nprojbins</span><span class="p">,</span> <span class="n">nprojbins</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rr</span><span class="p">),</span> <span class="n">qq</span> </div>
    <span class="c1">#return np.ones(nprojbins), np.ones((nprojbins, nprojbins))</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">doctest</span>
    <span class="n">doctest</span><span class="o">.</span><span class="n">testmod</span><span class="p">()</span>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/corrfunc_logo_320px_240px.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">Corrfunc v0.0.4</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../Corrfunc.html" >Corrfunc</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Corrfunc.utils</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2014-2020, Kate Storey-Fisher &lt;kstoreyfisher@gmail.com&gt;.
      Last updated on Sep 14, 2020.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.2.1.
    </div>
  </body>
</html>